### B树的插入
- 对一颗5阶BTree而言，节点的关键字个数$\lceil m/2 \rceil$-1 $\le$ n $\le$ m-1
- 这里就是2$\le$ n $\le$ 4 （省略失败（叶子）节点）
- 对下图这种情况（**新插入导致原节点超过关键字上限**），如果继续插入一个数 80
![image.png](https://iili.io/JfD39Qj.png)
- 会从中间位置$\lceil m/2 \rceil$ = 3  的位置将关键字分成两个部分。
![](https://iili.io/JfD3X87.png)
- 其中左边部分包含的关键字放在原节点中
- 右边部分包含的关键字放到新节点中
- 中间位置$\lceil m/2 \rceil$ = 3的节点作为源节点的父亲节点
![image.png](https://iili.io/JfDFWiv.png)


- 对于**插入新元素未超过关键字的情况**，新元素一定是插入到最底层的“终端节点”，并且使用“查找来确定插入位置”。
- 以上述BTree插入新元素90为例，90大于49，进到49的右侧节点，并且在新的节点的关键字中按序排列好。
![image.png](https://iili.io/JfDKZ2p.png)
- 插入的过程中不可以出现下面的错误
- 一定是要到底层的终端节点的
- **错误示范**
![image.png](https://iili.io/JfDfcwF.png)

- 再插入99
![image.png](https://iili.io/JfDf1na.png)

- 再插入88，这是个比较特殊的情况
- 88显然应该插入到80 和 90 之间的位置，88应当被提到父节点当中，左右两边分别放到不同的左右两个节点当中，就会变成下图的样子。
![image.png](https://iili.io/JfDqMxe.png)
- 接着插入83 87
![image.png](https://iili.io/JfDqZbt.png)


- 再插入一个70，则节点又需要分裂，80需要提到父节点当中
- 但80放到父节点的哪个位置呢？
- 依然需要保持父节点的元素有序，所以80放到49和88 的中间 
![image.png](https://iili.io/JfDqbXn.png)
- 排列好如下图，需要注意的是，
- 向上提的中间元素需要放到原先的节点（左节点）右侧的关键字位置，
- 然后新的节点（右节点）放到提上去的关键字的右侧的指针，
- 被我们挤走的88需要和右侧的指针保持相同的移动。
![image.png](https://iili.io/JfDBukB.png)

- 以此添加好 92 93 94 三个节点
- 需要分裂，把93提到当前父节点指向这个节点的指针右侧的关键字位置
![image.png](https://iili.io/JfDCkoF.png)

- 变化后如下
![image.png](https://iili.io/JfDCgcv.png)

- 如果此时插入一个73，需要提节点上去，并且原先73存在的节点需要分裂
![image.png](https://iili.io/JfDnKiu.png)

- 此时**父节点超限**，则需要对父节点也进行分裂操作
- 伴随父节点所有指针的更改
- 被提上去的元素的左边的指针不动，右边的所有指针跟随新的节点复制过去
![image.png](https://iili.io/JfDnMxt.png)


#### 总结B树插入的核心要求
**核心要求**
> 1. 对m阶BTree——除根节点外，其余节点的关键字个数$\lceil m/2 \rceil$-1 $\le$ n $\le$ m-1
> 2. 子树0 < 关键字1 < 子树1 < 关键字2 < 子树2 < ... 
> 3. 新元素一定是插入最底层的“终端节点”，用“查找”来确定查找位置
> 4. 在插入key后，若导致原结点关键字数超过上限，则从中间位置(<mark style="background: #FFB8EBA6;">**$\lceil m/2 \rceil$</mark>**)将其中的关键字 **分为两部分**，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置($\lceil m/2 \rceil$）的结点插入原结点的父结点，若此时导致**父节点的关键字**个数也**超过了上限**，则**继续进行这种分裂操作**，直至这个过程**传到根结点为止**，进而导致B树高度增1。




### BTree 的删除
- 若被删除的关键字在**终端节点**，则直接删除该关键字（要注意节点关键字个数是否低于下限$\lceil m/2 \rceil-1$ ）
- 比如删除60这个元素，直接删除
![image.png](https://iili.io/JfDzoJf.png)
- 删除后
- ![image.png](https://iili.io/JfDzMzB.png)

- 如果继续删除80这个元素（**非终端节点**），则用直接前驱或者直接后驱来替代被删除的关键字
- **直接前驱**：当前关键字左侧指针所指子树中最右下的元素（一定是终端节点）
![image.png](https://iili.io/JfDTIM7.png)
- 替换后如下图所示
![image.png](https://iili.io/JfDTiN4.png)

- 此时我们继续删除77这个元素
- 使用**直接后驱**：当前关键字右侧指针所指子树中最左下的操作
- 82便被提上去了
![image.png](https://iili.io/JfDRsDv.png)

- 如果删除节点导致终端节点内关键字数量低于下限该怎么办呢？
- 尝试删除节点38
- 因为38的这个节点关键字不够了，需要看他的兄弟节点
- 可以查看右（或左）兄弟节点的关键字个数，则需要调整该节点、右（或左）兄弟节点，及其双亲节点（父子换位法）
- 但肯定不是70直接过来
![image.png](https://iili.io/JfDl1ob.png)
- 可以拉下来49，再把70送上去
- 而上述过程实际上就是**右兄弟关键字足够的时候**，使用当前节点**后继、后继的后继**来填补空缺
![image.png](https://iili.io/JfD0MIn.png)




- 再来一个借左兄弟关键字的例子
- 删除节点 90或者92（这两个是一样的） 
- 右兄弟关键字不够，左兄弟是够的
- 需要前驱（节点中关键字），以及前驱的前驱顶替这个位置
- 删除90，则父节点的88下来（因为88的右侧指针指向90所在的节点位置）
- 88左侧的节点中的最右侧元素87上到父节点的位置
![image.png](https://iili.io/JfD0kk7.png)

- 如果兄弟不够借，比如上图的元素删除了一个49，没有左兄弟，右兄弟不够借
- 左右兄弟关键字个数均 = $\lceil m/2 \rceil-1$ ，则将关键字删除后**与左（或右）兄弟节点**及**双亲节点中的关键字**合并
- 下面是操作过程
![image.png](https://iili.io/JfDEnN1.png)
![image.png](https://iili.io/JfDEzog.png)
- 并且此时导致**父节点节点也不够**了，那要父节点首先要借节点，但左右兄弟都不够
- 于是父节点和他父节点以及的左右兄弟合并，
![image.png](https://iili.io/JfDEaRI.png)
![image.png](https://iili.io/JfDE1xn.png)

- 然后删除根节点就可以了

**合并过程注意事项**
	1. 合并过程中，双亲节点中的关键字个数会减少1。
	2. 若其双亲结点是根节点，且关键字个数减少至0（根节点关键字个数未1时右两颗子树），则直接删除根节点，合并后的节点成为根。
	3. 若双亲节点不是根节点，且关键字个数减少至 $\lceil m/2 \rceil-2$ （比最少的情况少1），则它又需要与自己的兄弟节点进行调整或合并操作，重复上述步骤，直至符合BTree的要求为止。







### 知识回顾
![image.png](https://iili.io/JfDM2YQ.png)
