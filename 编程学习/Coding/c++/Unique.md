``` cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 1e6 +9;
int a[N];
int main()
{
    int _;
    cin >> _;
    while (_--)
    {
        int n;
        cin >> n;
        for (int i = 1; i <= n; ++i)
        {
            cin >> a[i];
        }
        sort(a + 1, a + n + 1);
        int m = unique(a + 1, a + n + 1);
        
    }
}
```
Q：int m = unique(a + 1, a + n + 1);报错，而 int m = unique(a + 1, a + n + 1)-a;不报错，这是为什么？

A：你遇到的问题涉及到 `std::unique` 函数的返回类型和如何处理这个返回类型。首先，需要澄清的是，`std::unique` 函数返回的是一个迭代器，而不是一个整数。这就是为什么直接将 `std::unique` 的返回值赋给一个整数类型变量会导致编译错误。

### 解释错误

- **`int m = unique(a + 1, a + n + 1);`**：这里尝试将一个迭代器（在这个上下文中，可能是指针，因为 `a` 看起来是一个数组的名字）直接赋值给一个整数变量 `m`。由于迭代器类型（或指针类型）不能直接转换为 `int` 类型，这会导致编译时错误。

### 正确的做法

- **`int m = unique(a + 1, a + n + 1) - a;`**：在这个表达式中，`std::unique` 返回一个指向数组新逻辑末尾的迭代器（或在数组上下文中的指针）。通过从这个迭代器（指针）中减去数组的起始地址 `a`，你得到的是两个指针之间的差值，这个差值表示去重后数组的新逻辑长度。这是合法的操作，因为两个指针的减法操作结果是它们之间的距离，这个距离是一个整数，因此可以赋值给 `m`。

### 总结

`std::unique` 返回一个迭代器（在数组的情况下是一个指针），指向容器去重后新的逻辑末尾。当你需要计算去重后的容器或数组的长度时，应该计算这个迭代器与容器或数组起始位置的差值。直接将 `std::unique` 的返回值赋给一个整型变量会导致类型不匹配的编译错误，正确的做法是计算返回的迭代器（或指针）与起始迭代器（或数组名）之间的差值，这样就可以得到一个整数值，表示去重后的元素数量。