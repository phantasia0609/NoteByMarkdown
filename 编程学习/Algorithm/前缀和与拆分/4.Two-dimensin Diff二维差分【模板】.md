- [[#题目描述|题目描述]]
- [[#输入描述|输入描述]]
- [[#输出描述|输出描述]]
- [[#输入样例1|输入样例1]]
- [[#输出样例1|输出样例1]]
	- [[#输出样例1#分析|分析]]

## 题目描述

给定一个n行m列的整数矩阵。

有q个操作，每个操作格式为：x1​，y1​，x2​，y2​，c，其中(x1​,y1​)、(x2​，y2​)分别表示一个子矩阵的左上角和右下角的坐标，每个操作将对应的子矩阵的每个元素加上c。

请输出进行完所有操作后的矩阵。

## 输入描述

第一行包括三个整数 n,m,q（1≤n,m≤10^3,1≤q≤10^5）。

## 输出描述

共n行，每行包括m个整数，表示进行完所有操作后的矩阵。

## 输入样例1

```undefined
4 3 3
1 5 1 
3 3 2 
5 3 4 
4 4 2 
1 2 1 2 2
2 1 2 3 2
4 2 4 3 1
```

## 输出样例1

```undefined
1 7 1 
5 5 4 
5 3 4 
4 5 3 
```


### 分析
- 实现一个操作，选择一个矩形，为矩形内的元素统一加上一个常数x
- 如果差分数组已知，对差分数组中的某个位置加上常数 x，会让这个位置的右下方所有元素全部增加 x，（*加了一遍*或者是*加了两遍减了一遍*）通过这个原理可以构造出局部矩阵增加 x。
- 根据这个原理也可以通过原数组构造出差分数组，
```cpp
for(int i = 1;i <= n; ++ i) 
	for(int j = 1;j <= m; ++ j) { 
		d[i][j] += a[i][j]; 
		d[i + 1][j] -= a[i][j]; 
		d[i][j + 1] -= a[i][j]; 
		d[i + 1][j + 1] += a[i][j]; 
	}
``` 
- 和上述代码一样，如果这么做，就能将当前位置的这么一个 1 * 1 的矩阵在进行前缀和的时候变成 `a[i][j]`，主要是保证了当前位置进行前缀和的时候可以刚好加上完整的 `a[i][j]`，是十分好的前缀和的用途。
- 差分数组中的每个元素代表了在进行前缀和获得原数组时，右下方区域都会加一遍这个数，让差分数组在前缀和的过程中获得原数组，所以可以通过原数组反算查封数组
![image.png](https://iili.io/J0WThXt.png) 
- 前缀和、原数组、差分数组的关系*我们知道：（实际上本题的差分数组和原数组一致，解释在下面）当然也可以认为差分数组是一个全 0 数组，直接对差分数组中某些位置进行修改，修改后将差分数组和原数组加和也是完全可行的）*
- ![image.png](https://iili.io/J0AwkR2.png)
- *那么如何求得二维差分数组？*
- 其实能够稍稍感觉出二维差分和原先的一维数组差分不太相同，而实际上一维数组的差分的计算公式相当直观，二维差分，*如何定义差分* 都成为了难题，一维差分数组的含义是 diff 是原数组 a 相邻两个元素之间的差值，*二维差分数组的定义可以是当前数组右下方区域应当增加的值（这是我们上面分析得来的，当前位置变化可以改变右下角整个区域的值）*
- 关键：<mark style="background: #FFF3A3A6;">对差分数组进行 +x -x 的操作后，进行前缀和处理，将差分数组与原数组加和即可</mark>

Code
``` cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 1e3 + 9;

int a[N][N], prefix[N][N], diff[N][N];

int main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  int n, m, q;
  cin >> n >> m >> q;
  // 输入数组
  for (int i = 1; i <= n; ++i)
    for (int j = 1; j <= m; ++j) cin >> a[i][j];
  // choice1:修改全为0的差分数组 获得真正的差分数组
  for (int i = 1; i <= n; ++i)
    for (int j = 1; j <= m; ++j) {
      diff[i][j] += a[i][j];
      diff[i + 1][j] -= a[i][j];
      diff[i][j + 1] -= a[i][j];
      diff[i + 1][j + 1] += a[i][j];
    }
  // choice2:通过反算直接求得差分数组的值
  // for (int i = 1; i <= n; ++i) {
    // for (int j = 1; j <= m; ++j) {
      // diff[i][j] = a[i][j] - a[i - 1][j] - a[i][j - 1] + a[i - 1][j - 1];
    // }
  // }

  // 修改差分数组
  while (q--) {
    int x1, y1, x2, y2, c;
    cin >> x1 >> y1 >> x2 >> y2 >> c;
    diff[x1][y1] += c;
    diff[x1][y2 + 1] -= c;
    diff[x2 + 1][y1] -= c;
    diff[x2 + 1][y2 + 1] += c;
  }

  // 计算原数组
  for (int i = 1; i <= n; ++i)
    for (int j = 1; j <= m; ++j)
      a[i][j] = a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1] + diff[i][j];

  // 打印数组
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= m; j++) cout << a[i][j] << ' ';
    cout << '\n';
  }
  return 0;
}
```