![ce89659ba2b94e9cdce7a1a3042e4bcf.png](https://iili.io/JECZa0N.png)
# 题 1
## 题目描述

给定一个大小为n的单调不减的非负整数序列a（下标从1开始），再给出q个询问。

对于每个询问，给出一个整数x，你需要回答出，x第一次在给定序列a中出现的下标。

## 输入描述

第一行：两个整数 n,q。（1≤n,q≤2×10^5）

第二行：n 个整数，表示 a1​,a2​,⋅⋅⋅,an​。（0≤a_i​≤10^9，1≤i≤n）

第三行：q 个整数，表示询问的具体数字。（0≤x≤10^9）

## 输出描述

共一行，q个整数，表示每个询问数字在序列中第一次出现的下标，若不存在，则为−1。

## 输入样例1

```undefined
7 3
0 0 1 2 2 5 7
1 2 8
```

## 输出样例1

```undefined
3 4 -1
```

### 题解 （超级简单的二分）?jiandan jimao
``` cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 1e5 + 9;
int a[N];
void f()
{
    int n, q;
    cin >> n >> q;
    for (int i = 1; i <= n; ++i)
        cin >> a[i];
    while (q--)
    {
		// 返回r  如果返回l int l = 1, r = n + 1;
        int l = 0, r = n;
        int x;
        cin >> x;
        while (l + 1 != r)
        {

            int mid = (l + r) >> 1;
            if (a[mid] < x)
                l = mid;
            else
                r = mid;
        }
        if (a[r] == x)
            cout << r << ' ';
        else
            cout << -1 << ' ';
    }
}

int main()
{
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    f();
    return 0;
}
```

### 代码中所需要解释的问题
>Q：为什么 `l ` 从 0 开始？
>
>A：`l` 从0开始，而不是1，是因为这样的初始条件配合循环中的检查可以保证即使查找的值小于数组中的所有元素，循环也能正确终止。这种方法简化了逻辑，因为它避免了在循环开始前需要特殊处理数组的第一个元素的情况。此外，它确保了 `l` 和 `r` 的更新逻辑保持一致和简洁，无需额外的边界检查。（*就是如此简单，为了防止 r 为 1 的情况，因为剩下的情况的话要么最终 x 在 1 位置，要么 l 会移动到 0 之外的数字*）

>Q：为什么 l 和 r 都要更改为 mid？而不是 mid-1 或者 mid+1？
>A：在二分查找的实现中，是否将 `l` 和 `r` 更新为 `mid`、`mid-1` 或 `mid+1` 取决于具体的问题需求和如何定义查找区间。具体到这个问题，我们有两种主要的二分查找变种：**查找给定值的确切位置**和**查找给定值应该插入的位置**（即上界或下界）。这个代码示例中的逻辑旨在查找给定值的确切位置，而不是它的上下界。
#### 为什么使用 `mid` 而不是 `mid-1` 或 `mid+1`?

>- **更新 `l` 为 `mid`**：这是因为我们正在查找第一个大于或等于 `x` 的元素的位置。当我们发现 `a[mid] < x` 时，意味着 `mid` 及其左侧的所有元素都不可能是我们要找的目标，所以我们把 `l` 更新为 `mid` 而不是 `mid+1`，因为我们的目标是找到**恰好等于 `x`**的元素，而不是大于或等于 `x` 的最小元素。这样做是为了确保如果目标元素存在，它仍然在新的搜索区间内。

>- **更新 `r` 为 `mid`**：当我们发现 `a[mid] >= x` 时，`mid` 可能是我们要找的元素，或者更小的索引可能是我们要找的元素。所以，我们将 `r` 更新为 `mid`，而不是 `mid-1`，以确保不会错过目标元素。

>这种方法的关键在于，它试图保持查找范围内总是包含可能的目标元素，直到最终确定其位置或者确定目标元素不存在。如果我们使用 `mid-1` 或 `mid+1` 来更新 `l` 或 `r`，我们可能会无意中排除包含目标值的正确位置，尤其是在边界情况下。

#### 循环终止条件
>循环的终止条件是 `l + 1 != r`，这意味着当 `l` 和 `r` 相邻时循环结束。这个条件与更新逻辑配合，确保了不会错过查找的元素，同时也避免了无限循环的可能。

# 题 2 进击的奶牛

![ce89659ba2b94e9cdce7a1a3042e4bcf.png](https://iili.io/JECZa0N.png)

>- y 轴是可以放的奶牛的数量
>- x 轴是最小的距离![](https://iili.io/JETxMsn.png)
>- c 是现在有的奶牛，我们要求存放的奶牛数大于 c，并且 x 要尽可能的大。
>- 所以这是一个(0,l)的有边界问题，最终使用的是 l
>- ![image.png](https://iili.io/JETutyv.png)

``` cpp 
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 2e5 + 9;

int a[N], n, c;

// mid 叫做 dist是因为这是尝试的距离 返回可以放下的奶牛的数量
int check(int mid)
{
    int num = 0;    // 放下奶牛的数量
    int pre = -1e9; // 上一个奶牛的位置（就是我们输入的具体位置 比如 1 2 4 6 7
    for (int i = 1; i <= n; ++i)
    {
    	// 大于等于
        if (a[i] - pre >= mid)
            ++num, pre = a[i];
    }
    return num >= c;
}

void solve()
{
    cin >> n >> c;
    for (int i = 1; i <= n; ++i)
        cin >> a[i];
    sort(a + 1, a + 1 + n);
    int l = 0, r = 1e9 + 10;

    while (l + 1 != r)
    {
        int mid = (l + r) >> 1;
        if (check(mid))
        // mid 距离是可以放完所有奶牛的，所以l当然可以，所以l往更大的方向收缩
            l = mid;
        else
            r = mid;
    }

    cout << l << '\n';
}

int main()
{
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    solve();
    return 0;
} 
```


# 题 3 最长连续不重复子序列——二分
本题有T 组测试样例，对于每组样例：

给定一个长度为n的数组，求其中最长的连续且无重复数字的子序列的长度。

### 输入格式

第一行一个整数T，表示样例数。(1≤T≤10)

第一行一个整数n。(1≤n≤105)

第二行n个整数ai​。(1≤ai​≤105)

数据保证 $\sum n$ ≤10^5。

### 输出格式

一个整数表示答案。

### 样例输入1

```
1
5
1 2 2 3 5
```

### 样例输出1

```
3
```

解释：[2,3,5]为答案。

### 样例输入2

```
3
9
2 1 1 1 5 7 8 9 9
3
1 1 1
4
1 2 3 2
```

### 样例输出2

```
5
1
3
```

解释：[1,5,7,8,9]为答案。

### 题解
>- 使用二分思想
>- 通过不断探测相应长度的字符串是否存在，来得到最长的连续不重复子序列
>- 并且这题也是典型的右边界问题 ![image.png|400](https://iili.io/JET0wG4.png) ![image.png](https://iili.io/JETEIzg.png)
>- 


